(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{160:function(t,a,e){"use strict";e.r(a);var s=e(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"java8-新特性之-stream"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java8-新特性之-stream","aria-hidden":"true"}},[t._v("#")]),t._v(" java8 新特性之 stream")]),e("p",[t._v("本篇文章主要内容：")]),e("ul",[e("li",[t._v("介绍 Stream 以及 Stream 是如何处理集合的")]),e("li",[t._v("介绍 Stream 与集合的关系与区别")]),e("li",[t._v("Stream 的基本方法介绍")])]),e("p",[e("strong",[t._v("什么是 Stream")]),t._v("\nStream 中文称为 “流”，通过将集合转换为这么一种叫做 “流” 的元素序列，通过"),e("code",[t._v("声明性方式")]),t._v("，能够对集合中的每个元素进行一系列并行或串行的流水线操作。")]),e("p",[t._v("换句话说，你只需要告诉流你的要求，流便会在背后自行根据要求对元素进行处理，而你只需要 “坐享其成”。")]),e("p",[e("strong",[t._v("流操作")])]),e("p",[t._v("整个流操作就是一条流水线，将元素放在流水线上一个个地进行处理。")]),e("p",[t._v("其中数据源便是原始集合，然后将如 List的集合转换为 Stream类型的流，并对流进行一系列的中间操作，比如"),e("code",[t._v("过滤保留部分元素")]),t._v("、"),e("code",[t._v("对元素进行排序")]),t._v("、"),e("code",[t._v("类型转换")]),t._v("等；最后再进行一个终端操作，可以把 Stream 转换回集合类型，也可以直接对其中的各个元素进行处理，比如打印、比如计算总数、计算最大值等等")]),e("p",[t._v("很重要的一点是，很多流操作本身就会返回一个流，所以多个操作可以直接连接起来，我们来看看一条 Stream 操作的代码：")]),e("p",[t._v("如果是以前，进行这么一系列操作，你需要做个迭代器或者 foreach 循环，然后遍历，一步步地亲力亲为地去完成这些操作；但是如果使用流，你便可以直接声明式地下指令，流会帮你完成这些操作。")]),e("p",[t._v("有没有想到什么类似的？是的，就像 SQL 语句一样， select username from user where id = 1，你只要说明：“我需要 id 是 1 （id = 1）的用户（user）的用户名（username ）”，那么就可以得到自己想要的数据，而不需要自己亲自去数据库里面循环遍历查找。")]),e("p",[e("strong",[t._v("流与集合")])]),e("p",[t._v("什么时候计算")]),e("p",[t._v("Stream 和集合的其中一个差异在于什么时候进行计算。")]),e("p",[t._v("一个集合，它会包含当前数据结构中所有的值，你可以随时增删，但是集合里面的元素毫无疑问地都是已经计算好了的。")]),e("p",[e("code",[t._v("流则是按需计算")]),t._v("，按照使用者的需要计算数据，你可以想象我们通过搜索引擎进行搜索，搜索出来的条目并不是全部呈现出来的，而且先显示最符合的前 10 条或者前 20 条，只有在点击 “下一页” 的时候，才会再输出新的 10 条。")]),e("p",[t._v("再比方在线观看电影和你硬盘里面的电影，也是差不多的道理。")]),e("p",[t._v("外部迭代和内部迭代\nStream 和集合的另一个差异在于迭代。")]),e("p",[t._v("我们可以把集合比作一个工厂的仓库，一开始工厂比较落后，要对货物作什么修改，只能工人亲自走进仓库对货物进行处理，有时候还要将处理后的货物放到一个新的仓库里面。在这个时期，我们需要亲自去做迭代，一个个地找到需要的货物，并进行处理，这叫做外部迭代。")]),e("p",[t._v("后来工厂发展了起来，配备了流水线作业，只要根据需求设计出相应的流水线，然后工人只要把货物放到流水线上，就可以等着接收成果了，而且流水线还可以根据要求直接把货物输送到相应的仓库。")]),e("p",[t._v("这就叫做内部迭代，流水线已经帮你把迭代给完成了，你只需要说要干什么就可以了（即设计出合理的流水线）。")]),e("p",[t._v("Java 8 引入 Stream 很大程度是因为，流的内部迭代可以自动选择一种合适你硬件的数据表示和并行实现；而以往程序员自己进行 foreach 之类的时候，则需要自己去管理并行等问题。")]),e("p",[e("strong",[t._v("一次性的流")])]),e("p",[t._v("流和迭代器类似，只能迭代一次。")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Stream<String> stream = list.stream().map(Person::getName).sorted().limit(10);         \nList<String> newList = stream.collect(toList());\nList<String> newList2 = stream.collect(toList());\n")])])]),e("p",[t._v("上面代码中第三行会报错，因为第二行已经使用过这个流，这个流已经被消费掉了")]),e("p",[t._v("四. 方法介绍，开始实战\n首先我们先创建一个 Person 泛型的 List")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('List<Person> list = new ArrayList<>();\nlist.add(new Person("jack", 20));\nlist.add(new Person("mike", 25));\nlist.add(new Person("tom", 30));\n')])])]),e("p",[t._v("Person 类包含年龄和姓名两个成员变量")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("private String name;\nprivateint age;\n")])])]),e("ol",[e("li",[t._v("stream() / parallelStream()\n最常用到的方法，将集合转换为流")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Listlist = new ArrayList();\n// return Stream<E>\nlist.stream();\n")])])]),e("p",[t._v("而 parallelStream() 是并行流方法，能够让数据集执行并行操作，后面会更详细地讲解")]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("filter(T -> boolean)\n保留 boolean 为 true 的元素\n保留年龄为 20 的 person 元素")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list = list.stream()\n            .filter(person -> person.getAge() == 20)\n            .collect(toList());\n")])])]),e("p",[t._v("打印输出 [Person{name='jack', age=20}]\ncollect(toList()) 可以把流转换为 List 类型，这个以后会讲解")]),e("ol",{attrs:{start:"3"}},[e("li",[t._v("distinct()\n去除重复元素，这个方法是通过类的 equals 方法来判断两个元素是否相等的")])]),e("p",[t._v("如例子中的 Person 类，需要先定义好 equals 方法，不然类似[Person{name='jack', age=20}, Person{name='jack', age=20}] 这样的情况是不会处理的")]),e("ol",{attrs:{start:"4"}},[e("li",[t._v("sorted() / sorted((T, T) -> int)\n如果流中的元素的类实现了 Comparable 接口，即有自己的排序规则，那么可以直接调用 sorted() 方法对元素进行排序，如 Stream")])]),e("p",[t._v("反之, 需要调用 sorted((T, T) -> int) 实现 Comparator 接口\n根据年龄大小来比较：")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list = list.stream()\n           .sorted((p1, p2) -> p1.getAge() - p2.getAge())\n           .collect(toList());\n")])])]),e("p",[t._v("当然这个可以简化为")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list = list.stream()\n           .sorted(Comparator.comparingInt(Person::getAge))\n           .collect(toList());\n")])])]),e("ol",{attrs:{start:"5"}},[e("li",[t._v("limit(long n)\n返回前 n 个元素")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list = list.stream()\n            .limit(2)\n            .collect(toList());\n")])])]),e("p",[t._v("打印输出 [Person{name='jack', age=20}, Person{name='mike', age=25}]")]),e("ol",{attrs:{start:"6"}},[e("li",[t._v("skip(long n)\n去除前 n 个元素")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list = list.stream()\n            .skip(2)\n            .collect(toList());\n")])])]),e("p",[t._v("打印输出 [Person{name='tom', age=30}]")]),e("p",[t._v("tips:")]),e("ul",[e("li",[t._v("用在 limit(n) 前面时，先去除前 m 个元素再返回剩余元素的前 n 个元素")]),e("li",[t._v("limit(n) 用在 skip(m) 前面时，先返回前 n 个元素再在剩余的 n 个元素中去除 m 个元素")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("list = list.stream()\n            .limit(2)\n            .skip(1)\n            .collect(toList());\n")])])]),e("p",[t._v("打印输出 [Person{name='mike', age=25}]")]),e("ol",{attrs:{start:"7"}},[e("li",[t._v("map(T -> R)\n将流中的每一个元素 T 映射为 R（类似类型转换）")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("List<String> newlist = \nlist.stream().map(Person::getName).collect(toList());\n")])])]),e("p",[t._v("newlist 里面的元素为 list 中每一个 Person 对象的 name 变量")]),e("ol",{attrs:{start:"8"}},[e("li",[t._v("flatMap(T -> Stream)\n将流中的每一个元素 T 映射为一个流，再把每一个流连接成为一个流")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('List<String> list = new ArrayList<>();\nlist.add("aaa bbb ccc");\nlist.add("ddd eee fff");\nlist.add("ggg hhh iii");\nlist = list.stream().map(s -> s.split(" ")).\nflatMap(Arrays::stream).collect(toList());\n')])])]),e("p",[t._v('上面例子中，我们的目的是把 List 中每个字符串元素以" "分割开，变成一个新的 List。')]),e("p",[t._v("首先 map 方法分割每个字符串元素，但此时流的类型为 Stream，因为 split 方法返回的是 String[ ] 类型；所以我们需要使用 flatMap 方法，先使用Arrays::stream将每个 String[ ] 元素变成一个 Stream流，然后 flatMap 会将每一个流连接成为一个流，最终返回我们需要的 Stream")]),e("ol",{attrs:{start:"9"}},[e("li",[t._v("anyMatch(T -> boolean)\n流中是否有一个元素匹配给定的 T -> boolean 条件\n是否存在一个 person 对象的 age 等于 20：")])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("boolean b = list.stream().anyMatch(person -> person.getAge() == 20);\n")])])]),e("ol",{attrs:{start:"10"}},[e("li",[e("p",[t._v("allMatch(T -> boolean)\n流中是否所有元素都匹配给定的 T -> boolean 条件")])]),e("li",[e("p",[t._v("noneMatch(T -> boolean)\n流中是否没有元素匹配给定的 T -> boolean 条件")])]),e("li",[e("p",[t._v("findAny() 和 findFirst()")])])]),e("ul",[e("li",[t._v("findAny()：找到其中一个元素 （使用 stream() 时找到的是第一个元素；使用 parallelStream() 并行时找到的是其中一个元素）")]),e("li",[t._v("findFirst()：找到第一个元素")])]),e("p",[t._v("值得注意的是，这两个方法返回的是一个 Optional对象，它是一个容器类，能代表一个值存在或不存在，这个后面会讲到")]),e("ol",{attrs:{start:"13"}},[e("li",[t._v("reduce((T, T) -> T) 和 reduce(T, (T, T) -> T)\n用于组合流中的元素，如求和，求积，求最大值等\n计算年龄总和：\nint sum = list.stream().map(Person::getAge).reduce(0, (a, b) -> a + b);\n与之相同:\nint sum = list.stream().map(Person::getAge).reduce(0, Integer::sum);\n其中，reduce 第一个参数 0 代表起始值为 0，lambda (a, b) -> a + b 即将两值相加产生一个新值。")])]),e("p",[t._v("同样地：\n计算年龄总乘积：\nint sum = list.stream().map(Person::getAge).reduce(1, (a, b) -> a * b);")]),e("p",[t._v("当然也可以")]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Optional<Integer> sum = list.stream().map(Person::getAge).reduce(Integer::sum);\n")])])]),e("p",[t._v("即不接受任何起始值，但因为没有初始值，需要考虑结果可能不存在的情况，因此返回的是 Optional 类型。")]),e("ol",{attrs:{start:"13"}},[e("li",[e("p",[t._v("count()\n返回流中元素个数，结果为 long 类型")])]),e("li",[e("p",[t._v("collect()\n收集方法，我们很常用的是 collect(toList())，当然还有 collect(toSet()) 等，参数是一个收集器接口，这个后面会另外讲。")])]),e("li",[e("p",[t._v("forEach()\n返回结果为 void，很明显我们可以通过它来干什么了，比方说：")])]),e("li",[e("p",[t._v("unordered()还有这个比较不起眼的方法，\n返回一个等效的无序流，当然如果流本身就是无序的话，那可能就会直接返回其本身")])])]),e("p",[t._v("打印各个元素：\nlist.stream().forEach(System.out::println);")]),e("p",[t._v("再比如说 MyBatis 里面访问数据库的 mapper 方法：\n向数据库插入新元素：\nlist.stream().forEach(PersonMapper::insertPerson);")])])}],!1,null,null,null);a.default=r.exports}}]);