(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{161:function(o,n,e){"use strict";e.r(n);var s=e(0),r=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var o=this,n=o.$createElement,e=o._self._c||n;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"one-off-dyno"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#one-off-dyno","aria-hidden":"true"}},[o._v("#")]),o._v(" One-Off Dyno")]),e("p",[o._v("在学习heroku的过程中，官方文档指明，在30s内系统接受不到请求，就会造成连接超时，所以在一些需要很长时间响应的业务，就要把它异步化，官方推荐的方式为使用MQ中间件。在add-on中有CLOUD_AMQP这一附加组件，添加成功后，就可以使用云端的rabbit-mq了。需要长时间处理的业务逻辑通过消息队列发送到worker dyno进行处理。")]),e("p",[o._v("在Procfile中声明Dyno类型，并且通过执行heroku ps:scale命令依靠dyno管理器进行管理。这些dynos负责应用的通用流程（比如处理Http请求或者处理后台工作等）")]),e("p",[o._v("当你把工程推送到heroku的时候，slug 编译器就会编译包含你的应用的一个slug，这个应用可能包含许多部分，比如web 服务器，控制应用，初始化数据库的脚本等。然而web dyno会在Procfile中定义并由平台进行管理，控制台和脚本只会在被需要的时候执行，这些就是One-Off dyno。\nOne-off dynos和其他类型的dyno一起运行，正像web worker或者其他formation dynos一样，他们会得到dyno动态隔离的所有好处。\n每一个dyno都有自己短暂的不与其他dyno共享的文件管理系统，当你断开的时候就会失效，这个文件系统使用slug归档文件，因此one-off dynos可以充分使用应用上的所有文件")]),e("p",[o._v("在one-off dynos (run with heroku run) 和 formation dynos (run with heroku ps:scale)主要有四种区别：")]),e("ul",[e("li",[o._v("1.one-off dyno通过终端连接，为STDIN和STDOUT提供逐个字符的TCP连接，这使得你可以使用控制台等交互式的进程，由于STDOUT将进入你的终端，因此日志中仅仅会记录下来dyno的启动和终止")]),e("li",[o._v("2.One-off dynos在你摁下Ctrl+C 或者 断开本地终端就会被终止，One-off dynos绝不会自动重启，无论它是自动终止还是你手动关闭。")]),e("li",[o._v("3.One-off dynos以run.N方法命名而不是以"),e("code",[o._v("<process-type>")]),o._v("N的形式命名。")]),e("li",[o._v("4.One-off dynos不会接收到HTTP请求，因为路由器只有把流量导入到命名为web.N的dyno上面。除了这些差异外，one-off dynos和其他formation dynos在管理上面没有区别。")])]),e("p",[o._v("当你使用heroku run的时候就会创建One-off dynos")])])}],!1,null,null,null);n.default=r.exports}}]);